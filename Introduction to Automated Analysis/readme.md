# Introduction to Automated Analysis


## About this Course
This course introduces state-of-the-art techniques for automated analysis.  Automated analysis encompasses both approaches to automatically generate a very large number of tests to check whether programs meet requirements, and also means by which it is possible to *prove* that software meets requirements and that it is free from certain commonly-occurring defects, such as divide-by-zero, overflow/underflow, deadlock, race-condition freedom, buffer/array overflow, uncaught exceptions, and several other commonly-occurring bugs that can lead to program failures or security problems.  The learner will become familiar with the fundamental theory and applications of such approaches, and apply a variety of automated analysis techniques on example programs.


## After completing this course, a learner will be able to:
* Understand the foundations of automated verification: randomization and symbolic representations
* Distinguish the strengths and weaknesses of random testing, symbolic analysis, static analysis, and model checking
* Use a variety of state-of-the-art static analysis and automated testing tools for automated verification
* Create executable requirements as an oracle suitable for automated testing and symbolic analysis
* Understand how the choice of oracle affects fault-finding for automated analysis strategies.
* Use automated testing to achieve full mutation coverage
* Create a test plan that utilizes both manually-written tests and automated tests towards maximizing rigor, minimizing effort and time, and minimizing test costs.


This course is intended for learners interested in understanding the principles of automation and the application of tools 
for analysis and testing of software  This knowledge would benefit several typical roles: Software Engineer, Software Engineer in Test, Test Automation Engineer, DevOps Engineer, Software Developer, Programmer, Computer Enthusiast. 

We expect that you have some familiarity with the Software development Life-Cycle, an understanding of the fundamentals of software testing, similar to what is covered in the Introduction to Software Testing and Black-box and White-Box Testing Courses.  

Familiarity with an object-oriented language such as Java or ability to pick-up Java syntax quickly to write and modify code, and willingness to use tools and IDEs are assumed.


## SKILLS GAINED
* Software Testing
* Formal Verification
* Test Automation


### Instructors
Mike
Whalen

Kevin Wendt
- Director of Graduate Studies, Software Engineering
- Department of Computer Science and Engineering



### University of Minnesota
The University of Minnesota is among the largest public research universities in the country, offering undergraduate, graduate, and professional students a multitude of opportunities for study and research. Located at the heart of one of the nationâ€™s most vibrant, diverse metropolitan communities, students on the campuses in Minneapolis and St. Paul benefit from extensive partnerships with world-renowned health centers, international corporations, government agencies, and arts, nonprofit, and public service organizations.
